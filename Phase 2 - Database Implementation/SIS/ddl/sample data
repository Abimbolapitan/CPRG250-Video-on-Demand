-- =========================================================
-- Populate sample data (1000+ rows per table)
-- =========================================================
SET search_path = vod;

-- Start clean (keeps structure, resets IDs)
TRUNCATE wishlist, movieactor, moviedirector, moviecategory, movieadvisory,
         rental, category, advisory, director, actor, movie, customer
RESTART IDENTITY CASCADE;

-- =====================
-- 1) Parent tables
-- =====================

-- 1.1 Customers: 1,200
INSERT INTO customer (firstname, lastname, email, phone, city, provincestate, postalcode)
SELECT
  'First' || gs, 'Last' || gs, 'user' || gs || '@example.com',
  NULL,                                  
  'City' || (gs % 50), 'AB', NULL        
FROM generate_series(1, 1200) AS gs;

-- 1.2 Movies: 1,200 (valid prices + booleans)
INSERT INTO movie (title, releasedate, durationminutes, rating,
                   isnewrelease, comingsoon, mostpopular, sdprice, hdprice)
SELECT
  'Movie ' || gs,
  DATE '2015-01-01' + ((gs % 3650))::int,
  80 + (gs % 101),                                               
  (ARRAY['G','PG','PG-13','R'])[1 + (gs % 4)],
  (gs % 5 = 0), (gs % 7 = 0), (gs % 3 = 0),
  (2.99 + (gs % 400)/100.0)::NUMERIC(7,2),
  (3.99 + (gs % 400)/100.0)::NUMERIC(7,2)                         
FROM generate_series(1, 1200) AS gs;

-- 1.3 Actors: 1,200
INSERT INTO actor (firstname, lastname, dateofbirth, email)
SELECT
  'ActorFirst' || gs, 'ActorLast' || gs,
  DATE '1970-01-01' + ((gs % 18000))::int,                       
  'actor' || gs || '@talent.com'
FROM generate_series(1, 1200) AS gs;

-- 1.4 Directors: 1,200
INSERT INTO director (firstname, lastname, dateofbirth, email)
SELECT
  'DirFirst' || gs, 'DirLast' || gs,
  DATE '1960-01-01' + ((gs % 22000))::int,
  'director' || gs || '@film.com'
FROM generate_series(1, 1200) AS gs;

-- 1.5 Categories: 1,200 (names unique)
INSERT INTO category (categoryname) 
SELECT 'Category ' || gs
FROM generate_series(1, 1200) AS gs;

-- Add a simple hierarchy for categories (set parent for most, ensure not self)
UPDATE category AS c
SET parentcategoryid = CASE
  WHEN c.categoryid > 50 THEN 1 + ((c.categoryid - 1) % 50)
  ELSE NULL
END
WHERE c.categoryid BETWEEN 1 AND 1200;

-- 1.6 Advisories: 1,200
INSERT INTO advisory (shortdescription, fulldescription)
SELECT
  'Advisory ' || gs,
  'Auto-generated advisory description #' || gs
FROM generate_series(1, 1200) AS gs;

-- =====================
-- 2) Bridge / child tables
-- =====================

-- 2.1 MovieDirector: ≥1,200 (ensure ≥1 per movie)
INSERT INTO moviedirector (movieid, directorid)
SELECT m_id, 1 + ((m_id - 1) % 1200)      
FROM generate_series(1, 1200) AS m_id;

-- Optional second director for some movies (co-directors)
INSERT INTO moviedirector (movieid, directorid)
SELECT m_id, 1 + ((m_id + 173) % 1200)
FROM generate_series(1, 400) AS m_id
ON CONFLICT DO NOTHING;

-- 2.2 MovieActor: 3 actors per movie ⇒ 3,600+ rows
INSERT INTO movieactor (movieid, actorid, rolename)
SELECT m_id, 1 + ((m_id*3 + offset) % 1200),
       'Role ' || offset
FROM generate_series(1, 1200) AS m_id
CROSS JOIN LATERAL (VALUES (1),(2),(3)) v(offset)
ON CONFLICT DO NOTHING;

-- 2.3 MovieCategory: 2 categories per movie ⇒ 2,400 rows
INSERT INTO moviecategory (movieid, categoryid)
SELECT m_id, 1 + ((m_id      ) % 1200)
FROM generate_series(1, 1200) AS m_id
UNION ALL
SELECT m_id, 1 + ((m_id + 77) % 1200)
FROM generate_series(1, 1200) AS m_id;

-- 2.4 MovieAdvisory: ~1 per movie for half the movies ⇒ 600+ rows
INSERT INTO movieadvisory (movieid, advisoryid)
SELECT m_id, 1 + ((m_id*11) % 1200)
FROM generate_series(1, 1200) AS m_id
WHERE m_id % 2 = 0
ON CONFLICT DO NOTHING;

-- 2.5 Wishlist: ≥1,200 unique pairs
INSERT INTO wishlist (customerid, movieid, dateadded)
SELECT
  1 + ((n - 1) % 1200) AS customerid,
  1 + ((n*7) % 1200)   AS movieid,
  now() - ((n % 365)) * INTERVAL '1 day'
FROM generate_series(1, 2000) AS n
ON CONFLICT DO NOTHING;

-- 2.6 Rental: 5,000 rows with valid 24h windows on a subset
WITH s AS (
  SELECT n,
         1 + ((n - 1) % 1200)        AS customerid,
         1 + ((n*17) % 1200)         AS movieid,
         now() - ((n % 365)) * INTERVAL '1 day' AS base_ts
  FROM generate_series(1, 5000) AS n
)
INSERT INTO rental (customerid, movieid, rentaldate, viewstartat, expiresat,
                    pricepaid, paidcardtype, paidcardnumber, customerrating)
SELECT
  s.customerid,
  s.movieid,
  s.base_ts,                                              -- rentaldate
  CASE WHEN s.n % 5 = 0 THEN s.base_ts + INTERVAL '2 hour' END AS viewstartat,
  CASE WHEN s.n % 5 = 0 THEN s.base_ts + INTERVAL '26 hour' END AS expiresat,   -- +24h from viewstart
  -- pick SD or HD price from the movie row
  CASE WHEN s.n % 2 = 0 THEN m.sdprice ELSE m.hdprice END AS pricepaid,
  -- add valid card for 10% of rows; else leave NULLs (passes checks)
  CASE WHEN s.n % 10 = 0 THEN 'VISA'::credit_card_type END AS paidcardtype,
  CASE WHEN s.n % 10 = 0 THEN '4111111111111111' END      AS paidcardnumber,
  -- rating only on some rows
  CASE WHEN s.n % 6 = 0 THEN 1 + (s.n % 5) END            AS customerrating
FROM s
JOIN movie m ON m.movieid = s.movieid;

-- =====================
-- 3) Row count sanity check (optional)
-- =====================
-- SELECT 'customer' tbl, COUNT(*) FROM customer UNION ALL
-- SELECT 'movie'   , COUNT(*) FROM movie UNION ALL
-- SELECT 'actor'   , COUNT(*) FROM actor UNION ALL
-- SELECT 'director', COUNT(*) FROM director UNION ALL
-- SELECT 'category', COUNT(*) FROM category UNION ALL
-- SELECT 'advisory', COUNT(*) FROM advisory UNION ALL
-- SELECT 'rental'  , COUNT(*) FROM rental UNION ALL
-- SELECT 'wishlist', COUNT(*) FROM wishlist UNION ALL
-- SELECT 'movieactor', COUNT(*) FROM movieactor UNION ALL
-- SELECT 'moviedirector', COUNT(*) FROM moviedirector UNION ALL
-- SELECT 'moviecategory' , COUNT(*) FROM moviecategory UNION ALL
-- SELECT 'movieadvisory' , COUNT(*) FROM movieadvisory;
